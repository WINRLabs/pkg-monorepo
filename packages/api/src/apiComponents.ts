/**
 * Generated by @openapi-codegen
 *
 * @version 2.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, ApiContext } from "./apiContext";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

export type CurrencyControllerGetLastPriceFeedError =
  Fetcher.ErrorWrapper<undefined>;

export type CurrencyControllerGetLastPriceFeedResponse =
  Schemas.PriceResponse[];

export type CurrencyControllerGetLastPriceFeedVariables =
  ApiContext["fetcherOptions"];

export const fetchCurrencyControllerGetLastPriceFeed = (
  variables: CurrencyControllerGetLastPriceFeedVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    CurrencyControllerGetLastPriceFeedResponse,
    CurrencyControllerGetLastPriceFeedError,
    undefined,
    {},
    {},
    {}
  >({ url: "/currency/get-last-prices", method: "get", ...variables, signal });

export const useCurrencyControllerGetLastPriceFeed = <
  TData = CurrencyControllerGetLastPriceFeedResponse,
>(
  variables: CurrencyControllerGetLastPriceFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CurrencyControllerGetLastPriceFeedResponse,
      CurrencyControllerGetLastPriceFeedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    CurrencyControllerGetLastPriceFeedResponse,
    CurrencyControllerGetLastPriceFeedError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/currency/get-last-prices",
      operationId: "currencyControllerGetLastPriceFeed",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCurrencyControllerGetLastPriceFeed(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerBetHistoryQueryParams = {
  game?:
    | "COINFLIP"
    | "RANGE"
    | "WHEEL"
    | "PLINKO"
    | "MOON"
    | "LOTTERY"
    | "RPS"
    | "DICE"
    | "LIMBO"
    | "SLOT"
    | "ROULETTE"
    | "MINES"
    | "VIDEO_POKER"
    | "KENO"
    | "BACCARAT"
    | "HORSE_RACE"
    | "BLACKJACK"
    | "HOLDEM_POKER"
    | "WINR_BONANZA"
    | "ONE_HAND_BLACKJACK";
  player?: string;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GameControllerBetHistoryError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerBetHistoryResponse = Schemas.PaginatedResonse & {
  data?: Schemas.GameResultDto[];
};

export type GameControllerBetHistoryVariables = {
  queryParams?: GameControllerBetHistoryQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerBetHistory = (
  variables: GameControllerBetHistoryVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerBetHistoryResponse,
    GameControllerBetHistoryError,
    undefined,
    {},
    GameControllerBetHistoryQueryParams,
    {}
  >({ url: "/game/bet-history", method: "get", ...variables, signal });

export const useGameControllerBetHistory = <
  TData = GameControllerBetHistoryResponse,
>(
  variables: GameControllerBetHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerBetHistoryResponse,
      GameControllerBetHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerBetHistoryResponse,
    GameControllerBetHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/bet-history",
      operationId: "gameControllerBetHistory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerBetHistory(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetChartQueryParams = {
  period: "DAY" | "WEEK" | "MONTH" | "UNRECOGNIZED";
};

export type GameControllerGetChartError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetChartResponse = Schemas.ChartObject[];

export type GameControllerGetChartVariables = {
  queryParams: GameControllerGetChartQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetChart = (
  variables: GameControllerGetChartVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetChartResponse,
    GameControllerGetChartError,
    undefined,
    {},
    GameControllerGetChartQueryParams,
    {}
  >({ url: "/game/chart", method: "get", ...variables, signal });

export const useGameControllerGetChart = <
  TData = GameControllerGetChartResponse,
>(
  variables: GameControllerGetChartVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetChartResponse,
      GameControllerGetChartError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetChartResponse,
    GameControllerGetChartError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/chart",
      operationId: "gameControllerGetChart",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetChart({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerFreeSpinTrigggerQueryParams = {
  player: string;
  token: string;
};

export type GameControllerFreeSpinTrigggerError =
  Fetcher.ErrorWrapper<undefined>;

export type GameControllerFreeSpinTrigggerVariables = {
  queryParams: GameControllerFreeSpinTrigggerQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerFreeSpinTriggger = (
  variables: GameControllerFreeSpinTrigggerVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.TransactionResponse,
    GameControllerFreeSpinTrigggerError,
    undefined,
    {},
    GameControllerFreeSpinTrigggerQueryParams,
    {}
  >({ url: "/game/free-spin-trigger", method: "get", ...variables, signal });

export const useGameControllerFreeSpinTriggger = <
  TData = Schemas.TransactionResponse,
>(
  variables: GameControllerFreeSpinTrigggerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TransactionResponse,
      GameControllerFreeSpinTrigggerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.TransactionResponse,
    GameControllerFreeSpinTrigggerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/free-spin-trigger",
      operationId: "gameControllerFreeSpinTriggger",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerFreeSpinTriggger(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerAssignUsernameError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerAssignUsernameVariables = {
  body: Schemas.AssignUsernameInput;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerAssignUsername = (
  variables: GameControllerAssignUsernameVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UsernameObject,
    GameControllerAssignUsernameError,
    Schemas.AssignUsernameInput,
    {},
    {},
    {}
  >({ url: "/game/assign-username", method: "post", ...variables, signal });

export const useGameControllerAssignUsername = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsernameObject,
      GameControllerAssignUsernameError,
      GameControllerAssignUsernameVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UsernameObject,
    GameControllerAssignUsernameError,
    GameControllerAssignUsernameVariables
  >({
    mutationFn: (variables: GameControllerAssignUsernameVariables) =>
      fetchGameControllerAssignUsername({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GameControllerGetUserProfileQueryParams = {
  wallet: string;
};

export type GameControllerGetUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetUserProfileVariables = {
  queryParams: GameControllerGetUserProfileQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetUserProfile = (
  variables: GameControllerGetUserProfileVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UsernameObject,
    GameControllerGetUserProfileError,
    undefined,
    {},
    GameControllerGetUserProfileQueryParams,
    {}
  >({ url: "/game/user-profile", method: "get", ...variables, signal });

export const useGameControllerGetUserProfile = <
  TData = Schemas.UsernameObject,
>(
  variables: GameControllerGetUserProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UsernameObject,
      GameControllerGetUserProfileError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.UsernameObject,
    GameControllerGetUserProfileError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/user-profile",
      operationId: "gameControllerGetUserProfile",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetUserProfile(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetMultiplayerGameHistoryQueryParams = {
  game?:
    | "COINFLIP"
    | "RANGE"
    | "WHEEL"
    | "PLINKO"
    | "MOON"
    | "LOTTERY"
    | "RPS"
    | "DICE"
    | "LIMBO"
    | "SLOT"
    | "ROULETTE"
    | "MINES"
    | "VIDEO_POKER"
    | "KENO"
    | "BACCARAT"
    | "HORSE_RACE"
    | "BLACKJACK"
    | "HOLDEM_POKER"
    | "WINR_BONANZA"
    | "ONE_HAND_BLACKJACK";
};

export type GameControllerGetMultiplayerGameHistoryError =
  Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetMultiplayerGameHistoryResponse =
  Schemas.MultiplayerGameHistoryObject[];

export type GameControllerGetMultiplayerGameHistoryVariables = {
  queryParams?: GameControllerGetMultiplayerGameHistoryQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetMultiplayerGameHistory = (
  variables: GameControllerGetMultiplayerGameHistoryVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetMultiplayerGameHistoryResponse,
    GameControllerGetMultiplayerGameHistoryError,
    undefined,
    {},
    GameControllerGetMultiplayerGameHistoryQueryParams,
    {}
  >({
    url: "/game/multiplayer-game-history",
    method: "get",
    ...variables,
    signal,
  });

export const useGameControllerGetMultiplayerGameHistory = <
  TData = GameControllerGetMultiplayerGameHistoryResponse,
>(
  variables: GameControllerGetMultiplayerGameHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetMultiplayerGameHistoryResponse,
      GameControllerGetMultiplayerGameHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetMultiplayerGameHistoryResponse,
    GameControllerGetMultiplayerGameHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/multiplayer-game-history",
      operationId: "gameControllerGetMultiplayerGameHistory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetMultiplayerGameHistory(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLiveWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLiveWinsResponse = Schemas.LiveWinsDto[];

export type GameControllerGetLiveWinsVariables = ApiContext["fetcherOptions"];

export const fetchGameControllerGetLiveWins = (
  variables: GameControllerGetLiveWinsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetLiveWinsResponse,
    GameControllerGetLiveWinsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/game/live-wins", method: "get", ...variables, signal });

export const useGameControllerGetLiveWins = <
  TData = GameControllerGetLiveWinsResponse,
>(
  variables: GameControllerGetLiveWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLiveWinsResponse,
      GameControllerGetLiveWinsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLiveWinsResponse,
    GameControllerGetLiveWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/live-wins",
      operationId: "gameControllerGetLiveWins",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLiveWins(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetBigWinsQueryParams = {
  range?: "ALL_TIME" | "DAY" | "WEEK" | "MONTH";
};

export type GameControllerGetBigWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetBigWinsResponse = Schemas.BigWinsDto[];

export type GameControllerGetBigWinsVariables = {
  queryParams?: GameControllerGetBigWinsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetBigWins = (
  variables: GameControllerGetBigWinsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetBigWinsResponse,
    GameControllerGetBigWinsError,
    undefined,
    {},
    GameControllerGetBigWinsQueryParams,
    {}
  >({ url: "/game/live-big-wins", method: "get", ...variables, signal });

export const useGameControllerGetBigWins = <
  TData = GameControllerGetBigWinsResponse,
>(
  variables: GameControllerGetBigWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetBigWinsResponse,
      GameControllerGetBigWinsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetBigWinsResponse,
    GameControllerGetBigWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/live-big-wins",
      operationId: "gameControllerGetBigWins",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetBigWins(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLiveLuckyWinsQueryParams = {
  range?: "ALL_TIME" | "DAY" | "WEEK" | "MONTH";
};

export type GameControllerGetLiveLuckyWinsError =
  Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLiveLuckyWinsResponse = Schemas.LuckyWinsDto[];

export type GameControllerGetLiveLuckyWinsVariables = {
  queryParams?: GameControllerGetLiveLuckyWinsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetLiveLuckyWins = (
  variables: GameControllerGetLiveLuckyWinsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetLiveLuckyWinsResponse,
    GameControllerGetLiveLuckyWinsError,
    undefined,
    {},
    GameControllerGetLiveLuckyWinsQueryParams,
    {}
  >({ url: "/game/live-lucky-wins", method: "get", ...variables, signal });

export const useGameControllerGetLiveLuckyWins = <
  TData = GameControllerGetLiveLuckyWinsResponse,
>(
  variables: GameControllerGetLiveLuckyWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLiveLuckyWinsResponse,
      GameControllerGetLiveLuckyWinsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLiveLuckyWinsResponse,
    GameControllerGetLiveLuckyWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/live-lucky-wins",
      operationId: "gameControllerGetLiveLuckyWins",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLiveLuckyWins(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLuckyWinsQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  wallet: string;
};

export type GameControllerGetLuckyWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLuckyWinsResponse = Schemas.PaginatedResonse & {
  data?: Schemas.LuckyWinsDto[];
};

export type GameControllerGetLuckyWinsVariables = {
  queryParams: GameControllerGetLuckyWinsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetLuckyWins = (
  variables: GameControllerGetLuckyWinsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetLuckyWinsResponse,
    GameControllerGetLuckyWinsError,
    undefined,
    {},
    GameControllerGetLuckyWinsQueryParams,
    {}
  >({ url: "/game/lucky-wins", method: "get", ...variables, signal });

export const useGameControllerGetLuckyWins = <
  TData = GameControllerGetLuckyWinsResponse,
>(
  variables: GameControllerGetLuckyWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLuckyWinsResponse,
      GameControllerGetLuckyWinsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLuckyWinsResponse,
    GameControllerGetLuckyWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/lucky-wins",
      operationId: "gameControllerGetLuckyWins",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLuckyWins(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetTopBetsQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  wallet: string;
};

export type GameControllerGetTopBetsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetTopBetsResponse = Schemas.PaginatedResonse & {
  data?: Schemas.LuckyWinsDto[];
};

export type GameControllerGetTopBetsVariables = {
  queryParams: GameControllerGetTopBetsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetTopBets = (
  variables: GameControllerGetTopBetsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GameControllerGetTopBetsResponse,
    GameControllerGetTopBetsError,
    undefined,
    {},
    GameControllerGetTopBetsQueryParams,
    {}
  >({ url: "/game/top-bets", method: "get", ...variables, signal });

export const useGameControllerGetTopBets = <
  TData = GameControllerGetTopBetsResponse,
>(
  variables: GameControllerGetTopBetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetTopBetsResponse,
      GameControllerGetTopBetsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetTopBetsResponse,
    GameControllerGetTopBetsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/top-bets",
      operationId: "gameControllerGetTopBets",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetTopBets(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetStatsByPlayerQueryParams = {
  wallet: string;
};

export type GameControllerGetStatsByPlayerError =
  Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetStatsByPlayerVariables = {
  queryParams: GameControllerGetStatsByPlayerQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGameControllerGetStatsByPlayer = (
  variables: GameControllerGetStatsByPlayerVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.PlayerRankObject,
    GameControllerGetStatsByPlayerError,
    undefined,
    {},
    GameControllerGetStatsByPlayerQueryParams,
    {}
  >({ url: "/game/stats-by-player", method: "get", ...variables, signal });

export const useGameControllerGetStatsByPlayer = <
  TData = Schemas.PlayerRankObject,
>(
  variables: GameControllerGetStatsByPlayerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlayerRankObject,
      GameControllerGetStatsByPlayerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.PlayerRankObject,
    GameControllerGetStatsByPlayerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/game/stats-by-player",
      operationId: "gameControllerGetStatsByPlayer",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetStatsByPlayer(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type RefundControllerRefundGameError = Fetcher.ErrorWrapper<undefined>;

export type RefundControllerRefundGameVariables = {
  body: Schemas.RefundInput;
} & ApiContext["fetcherOptions"];

export const fetchRefundControllerRefundGame = (
  variables: RefundControllerRefundGameVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.TransactionResponse,
    RefundControllerRefundGameError,
    Schemas.RefundInput,
    {},
    {},
    {}
  >({ url: "/refund/refund-game", method: "post", ...variables, signal });

export const useRefundControllerRefundGame = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TransactionResponse,
      RefundControllerRefundGameError,
      RefundControllerRefundGameVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.TransactionResponse,
    RefundControllerRefundGameError,
    RefundControllerRefundGameVariables
  >({
    mutationFn: (variables: RefundControllerRefundGameVariables) =>
      fetchRefundControllerRefundGame({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RefundControllerReIterateError = Fetcher.ErrorWrapper<undefined>;

export type RefundControllerReIterateVariables = {
  body: Schemas.RefundInput;
} & ApiContext["fetcherOptions"];

export const fetchRefundControllerReIterate = (
  variables: RefundControllerReIterateVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.TransactionResponse,
    RefundControllerReIterateError,
    Schemas.RefundInput,
    {},
    {},
    {}
  >({ url: "/refund/re-iterate", method: "post", ...variables, signal });

export const useRefundControllerReIterate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TransactionResponse,
      RefundControllerReIterateError,
      RefundControllerReIterateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.TransactionResponse,
    RefundControllerReIterateError,
    RefundControllerReIterateVariables
  >({
    mutationFn: (variables: RefundControllerReIterateVariables) =>
      fetchRefundControllerReIterate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StatisticControllerGetStatsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetStatsVariables = ApiContext["fetcherOptions"];

export const fetchStatisticControllerGetStats = (
  variables: StatisticControllerGetStatsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.JustBetStats,
    StatisticControllerGetStatsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/statistic/stats", method: "get", ...variables, signal });

export const useStatisticControllerGetStats = <TData = Schemas.JustBetStats,>(
  variables: StatisticControllerGetStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.JustBetStats,
      StatisticControllerGetStatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.JustBetStats,
    StatisticControllerGetStatsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/statistic/stats",
      operationId: "statisticControllerGetStats",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetStats(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetMiningStatsError =
  Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetMiningStatsVariables =
  ApiContext["fetcherOptions"];

export const fetchStatisticControllerGetMiningStats = (
  variables: StatisticControllerGetMiningStatsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MiningStatistics,
    StatisticControllerGetMiningStatsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/statistic/mininig-stats", method: "get", ...variables, signal });

export const useStatisticControllerGetMiningStats = <
  TData = Schemas.MiningStatistics,
>(
  variables: StatisticControllerGetMiningStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MiningStatistics,
      StatisticControllerGetMiningStatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.MiningStatistics,
    StatisticControllerGetMiningStatsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/statistic/mininig-stats",
      operationId: "statisticControllerGetMiningStats",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetMiningStats(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByVolumeQueryParams = {
  period?: "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY";
  sortBy?: "WON" | "BET" | "WINRATE" | "VOLUME" | "PROFIT" | "MULTIPLIER";
  sortOrder?: "ASC" | "DESC";
};

export type StatisticControllerGetLeaderboardListByVolumeError =
  Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByVolumeResponse =
  Schemas.LeaderboardVolumeObject[];

export type StatisticControllerGetLeaderboardListByVolumeVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByVolumeQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchStatisticControllerGetLeaderboardListByVolume = (
  variables: StatisticControllerGetLeaderboardListByVolumeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    StatisticControllerGetLeaderboardListByVolumeResponse,
    StatisticControllerGetLeaderboardListByVolumeError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByVolumeQueryParams,
    {}
  >({
    url: "/statistic/volume-leaderboard-list",
    method: "get",
    ...variables,
    signal,
  });

export const useStatisticControllerGetLeaderboardListByVolume = <
  TData = StatisticControllerGetLeaderboardListByVolumeResponse,
>(
  variables: StatisticControllerGetLeaderboardListByVolumeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StatisticControllerGetLeaderboardListByVolumeResponse,
      StatisticControllerGetLeaderboardListByVolumeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    StatisticControllerGetLeaderboardListByVolumeResponse,
    StatisticControllerGetLeaderboardListByVolumeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/statistic/volume-leaderboard-list",
      operationId: "statisticControllerGetLeaderboardListByVolume",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByVolume(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByProfitQueryParams = {
  period?: "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY";
  sortBy?: "WON" | "BET" | "WINRATE" | "VOLUME" | "PROFIT" | "MULTIPLIER";
  sortOrder?: "ASC" | "DESC";
};

export type StatisticControllerGetLeaderboardListByProfitError =
  Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByProfitResponse =
  Schemas.LeaderboardProfitObject[];

export type StatisticControllerGetLeaderboardListByProfitVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByProfitQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchStatisticControllerGetLeaderboardListByProfit = (
  variables: StatisticControllerGetLeaderboardListByProfitVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    StatisticControllerGetLeaderboardListByProfitResponse,
    StatisticControllerGetLeaderboardListByProfitError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByProfitQueryParams,
    {}
  >({
    url: "/statistic/profit-leaderboard-list",
    method: "get",
    ...variables,
    signal,
  });

export const useStatisticControllerGetLeaderboardListByProfit = <
  TData = StatisticControllerGetLeaderboardListByProfitResponse,
>(
  variables: StatisticControllerGetLeaderboardListByProfitVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StatisticControllerGetLeaderboardListByProfitResponse,
      StatisticControllerGetLeaderboardListByProfitError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    StatisticControllerGetLeaderboardListByProfitResponse,
    StatisticControllerGetLeaderboardListByProfitError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/statistic/profit-leaderboard-list",
      operationId: "statisticControllerGetLeaderboardListByProfit",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByProfit(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams = {
  period?: "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY";
  sortBy?: "WON" | "BET" | "WINRATE" | "VOLUME" | "PROFIT" | "MULTIPLIER";
  sortOrder?: "ASC" | "DESC";
};

export type StatisticControllerGetLeaderboardListByLuckyWinnerError =
  Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByLuckyWinnerResponse =
  Schemas.LeaderboardLuckyWinnerObject[];

export type StatisticControllerGetLeaderboardListByLuckyWinnerVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchStatisticControllerGetLeaderboardListByLuckyWinner = (
  variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
    StatisticControllerGetLeaderboardListByLuckyWinnerError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams,
    {}
  >({
    url: "/statistic/lucky-leaderboard-list",
    method: "get",
    ...variables,
    signal,
  });

export const useStatisticControllerGetLeaderboardListByLuckyWinner = <
  TData = StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
>(
  variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
      StatisticControllerGetLeaderboardListByLuckyWinnerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
    StatisticControllerGetLeaderboardListByLuckyWinnerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/statistic/lucky-leaderboard-list",
      operationId: "statisticControllerGetLeaderboardListByLuckyWinner",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByLuckyWinner(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams = {
  /**
   * comma separated
   */
  bankrollIndexes: string;
};

export type BankrollControllerUpdateSingleSidedPoolsNotifyError =
  Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerUpdateSingleSidedPoolsNotifyVariables = {
  queryParams: BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchBankrollControllerUpdateSingleSidedPoolsNotify = (
  variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    undefined,
    BankrollControllerUpdateSingleSidedPoolsNotifyError,
    undefined,
    {},
    BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams,
    {}
  >({
    url: "/bankroll/update-notify-single-sided-pools",
    method: "get",
    ...variables,
    signal,
  });

export const useBankrollControllerUpdateSingleSidedPoolsNotify = <
  TData = undefined,
>(
  variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      BankrollControllerUpdateSingleSidedPoolsNotifyError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    undefined,
    BankrollControllerUpdateSingleSidedPoolsNotifyError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/bankroll/update-notify-single-sided-pools",
      operationId: "bankrollControllerUpdateSingleSidedPoolsNotify",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerUpdateSingleSidedPoolsNotify(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerGetSingleSidedPoolsQueryParams = {
  /**
   * comma separated
   */
  bankrollIndexes: string;
  player?: string;
};

export type BankrollControllerGetSingleSidedPoolsError =
  Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerGetSingleSidedPoolsResponse =
  Schemas.VaultOutput[];

export type BankrollControllerGetSingleSidedPoolsVariables = {
  queryParams: BankrollControllerGetSingleSidedPoolsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchBankrollControllerGetSingleSidedPools = (
  variables: BankrollControllerGetSingleSidedPoolsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    BankrollControllerGetSingleSidedPoolsResponse,
    BankrollControllerGetSingleSidedPoolsError,
    undefined,
    {},
    BankrollControllerGetSingleSidedPoolsQueryParams,
    {}
  >({
    url: "/bankroll/single-sided-pools",
    method: "get",
    ...variables,
    signal,
  });

export const useBankrollControllerGetSingleSidedPools = <
  TData = BankrollControllerGetSingleSidedPoolsResponse,
>(
  variables: BankrollControllerGetSingleSidedPoolsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BankrollControllerGetSingleSidedPoolsResponse,
      BankrollControllerGetSingleSidedPoolsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    BankrollControllerGetSingleSidedPoolsResponse,
    BankrollControllerGetSingleSidedPoolsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/bankroll/single-sided-pools",
      operationId: "bankrollControllerGetSingleSidedPools",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerGetSingleSidedPools(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerGetPoolListError =
  Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerGetPoolListResponse = Schemas.PoolOutput[];

export type BankrollControllerGetPoolListVariables =
  ApiContext["fetcherOptions"];

export const fetchBankrollControllerGetPoolList = (
  variables: BankrollControllerGetPoolListVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    BankrollControllerGetPoolListResponse,
    BankrollControllerGetPoolListError,
    undefined,
    {},
    {},
    {}
  >({ url: "/bankroll/pool-list", method: "get", ...variables, signal });

export const useBankrollControllerGetPoolList = <
  TData = BankrollControllerGetPoolListResponse,
>(
  variables: BankrollControllerGetPoolListVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BankrollControllerGetPoolListResponse,
      BankrollControllerGetPoolListError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    BankrollControllerGetPoolListResponse,
    BankrollControllerGetPoolListError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/bankroll/pool-list",
      operationId: "bankrollControllerGetPoolList",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerGetPoolList(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerGetReferralHistoryByPlayerPathParams = {
  /**
   * User wallet address
   */
  wallet: string;
};

export type ReferralControllerGetReferralHistoryByPlayerQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type ReferralControllerGetReferralHistoryByPlayerError =
  Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerGetReferralHistoryByPlayerResponse =
  Schemas.PaginatedResonse & {
    data?: Schemas.ReferralRewardEntity[];
  };

export type ReferralControllerGetReferralHistoryByPlayerVariables = {
  pathParams: ReferralControllerGetReferralHistoryByPlayerPathParams;
  queryParams?: ReferralControllerGetReferralHistoryByPlayerQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchReferralControllerGetReferralHistoryByPlayer = (
  variables: ReferralControllerGetReferralHistoryByPlayerVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    ReferralControllerGetReferralHistoryByPlayerResponse,
    ReferralControllerGetReferralHistoryByPlayerError,
    undefined,
    {},
    ReferralControllerGetReferralHistoryByPlayerQueryParams,
    ReferralControllerGetReferralHistoryByPlayerPathParams
  >({
    url: "/referral/referral-history/{wallet}",
    method: "get",
    ...variables,
    signal,
  });

export const useReferralControllerGetReferralHistoryByPlayer = <
  TData = ReferralControllerGetReferralHistoryByPlayerResponse,
>(
  variables: ReferralControllerGetReferralHistoryByPlayerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerGetReferralHistoryByPlayerResponse,
      ReferralControllerGetReferralHistoryByPlayerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerGetReferralHistoryByPlayerResponse,
    ReferralControllerGetReferralHistoryByPlayerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/referral/referral-history/{wallet}",
      operationId: "referralControllerGetReferralHistoryByPlayer",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerGetReferralHistoryByPlayer(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerRewardsDistributionHistoryPathParams = {
  /**
   * User wallet address
   */
  wallet: string;
};

export type ReferralControllerRewardsDistributionHistoryQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type ReferralControllerRewardsDistributionHistoryError =
  Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerRewardsDistributionHistoryResponse =
  Schemas.PaginatedResonse & {
    data?: Schemas.ReferralClaimEntity[];
  };

export type ReferralControllerRewardsDistributionHistoryVariables = {
  pathParams: ReferralControllerRewardsDistributionHistoryPathParams;
  queryParams?: ReferralControllerRewardsDistributionHistoryQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchReferralControllerRewardsDistributionHistory = (
  variables: ReferralControllerRewardsDistributionHistoryVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    ReferralControllerRewardsDistributionHistoryResponse,
    ReferralControllerRewardsDistributionHistoryError,
    undefined,
    {},
    ReferralControllerRewardsDistributionHistoryQueryParams,
    ReferralControllerRewardsDistributionHistoryPathParams
  >({
    url: "/referral/rewards-distribution-history/{wallet}",
    method: "get",
    ...variables,
    signal,
  });

export const useReferralControllerRewardsDistributionHistory = <
  TData = ReferralControllerRewardsDistributionHistoryResponse,
>(
  variables: ReferralControllerRewardsDistributionHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerRewardsDistributionHistoryResponse,
      ReferralControllerRewardsDistributionHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerRewardsDistributionHistoryResponse,
    ReferralControllerRewardsDistributionHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/referral/rewards-distribution-history/{wallet}",
      operationId: "referralControllerRewardsDistributionHistory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerRewardsDistributionHistory(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerCodesVolumeAndRewardAmountsQueryParams = {
  codes: string;
};

export type ReferralControllerCodesVolumeAndRewardAmountsError =
  Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerCodesVolumeAndRewardAmountsResponse =
  Schemas.CodesVolumeAndReward[];

export type ReferralControllerCodesVolumeAndRewardAmountsVariables = {
  queryParams: ReferralControllerCodesVolumeAndRewardAmountsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchReferralControllerCodesVolumeAndRewardAmounts = (
  variables: ReferralControllerCodesVolumeAndRewardAmountsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    ReferralControllerCodesVolumeAndRewardAmountsResponse,
    ReferralControllerCodesVolumeAndRewardAmountsError,
    undefined,
    {},
    ReferralControllerCodesVolumeAndRewardAmountsQueryParams,
    {}
  >({
    url: "/referral/code-volume-and-rewards",
    method: "get",
    ...variables,
    signal,
  });

export const useReferralControllerCodesVolumeAndRewardAmounts = <
  TData = ReferralControllerCodesVolumeAndRewardAmountsResponse,
>(
  variables: ReferralControllerCodesVolumeAndRewardAmountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerCodesVolumeAndRewardAmountsResponse,
      ReferralControllerCodesVolumeAndRewardAmountsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerCodesVolumeAndRewardAmountsResponse,
    ReferralControllerCodesVolumeAndRewardAmountsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/referral/code-volume-and-rewards",
      operationId: "referralControllerCodesVolumeAndRewardAmounts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerCodesVolumeAndRewardAmounts(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type BadgeControllerAwardBadgeError = Fetcher.ErrorWrapper<undefined>;

export type BadgeControllerAwardBadgeVariables = {
  body: Schemas.AwardBadge;
} & ApiContext["fetcherOptions"];

export const fetchBadgeControllerAwardBadge = (
  variables: BadgeControllerAwardBadgeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.AwardBadgeResponse,
    BadgeControllerAwardBadgeError,
    Schemas.AwardBadge,
    {},
    {},
    {}
  >({ url: "/badge/award", method: "post", ...variables, signal });

export const useBadgeControllerAwardBadge = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AwardBadgeResponse,
      BadgeControllerAwardBadgeError,
      BadgeControllerAwardBadgeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.AwardBadgeResponse,
    BadgeControllerAwardBadgeError,
    BadgeControllerAwardBadgeVariables
  >({
    mutationFn: (variables: BadgeControllerAwardBadgeVariables) =>
      fetchBadgeControllerAwardBadge({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BadgeControllerWeeklyClaimerError = Fetcher.ErrorWrapper<undefined>;

export type BadgeControllerWeeklyClaimerVariables = {
  body: Schemas.WeeklyClaimer;
} & ApiContext["fetcherOptions"];

export const fetchBadgeControllerWeeklyClaimer = (
  variables: BadgeControllerWeeklyClaimerVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.BadgeResponse,
    BadgeControllerWeeklyClaimerError,
    Schemas.WeeklyClaimer,
    {},
    {},
    {}
  >({ url: "/badge/weekly-claimer", method: "post", ...variables, signal });

export const useBadgeControllerWeeklyClaimer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BadgeResponse,
      BadgeControllerWeeklyClaimerError,
      BadgeControllerWeeklyClaimerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BadgeResponse,
    BadgeControllerWeeklyClaimerError,
    BadgeControllerWeeklyClaimerVariables
  >({
    mutationFn: (variables: BadgeControllerWeeklyClaimerVariables) =>
      fetchBadgeControllerWeeklyClaimer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StakeControllerSummaryError = Fetcher.ErrorWrapper<undefined>;

export type StakeControllerSummaryVariables = ApiContext["fetcherOptions"];

export const fetchStakeControllerSummary = (
  variables: StakeControllerSummaryVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SummaryResponse,
    StakeControllerSummaryError,
    undefined,
    {},
    {},
    {}
  >({ url: "/stake/summary", method: "get", ...variables, signal });

export const useStakeControllerSummary = <TData = Schemas.SummaryResponse,>(
  variables: StakeControllerSummaryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SummaryResponse,
      StakeControllerSummaryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SummaryResponse,
    StakeControllerSummaryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/stake/summary",
      operationId: "stakeControllerSummary",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStakeControllerSummary({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type RankControllerTakeLevelupSnapshotError =
  Fetcher.ErrorWrapper<undefined>;

export type RankControllerTakeLevelupSnapshotVariables = {
  body: Schemas.TakeLevelupSnapshotInput;
} & ApiContext["fetcherOptions"];

export const fetchRankControllerTakeLevelupSnapshot = (
  variables: RankControllerTakeLevelupSnapshotVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    undefined,
    RankControllerTakeLevelupSnapshotError,
    Schemas.TakeLevelupSnapshotInput,
    {},
    {},
    {}
  >({
    url: "/rank/take-levelup-snapshot",
    method: "post",
    ...variables,
    signal,
  });

export const useRankControllerTakeLevelupSnapshot = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RankControllerTakeLevelupSnapshotError,
      RankControllerTakeLevelupSnapshotVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    RankControllerTakeLevelupSnapshotError,
    RankControllerTakeLevelupSnapshotVariables
  >({
    mutationFn: (variables: RankControllerTakeLevelupSnapshotVariables) =>
      fetchRankControllerTakeLevelupSnapshot({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/currency/get-last-prices";
      operationId: "currencyControllerGetLastPriceFeed";
      variables: CurrencyControllerGetLastPriceFeedVariables;
    }
  | {
      path: "/game/bet-history";
      operationId: "gameControllerBetHistory";
      variables: GameControllerBetHistoryVariables;
    }
  | {
      path: "/game/chart";
      operationId: "gameControllerGetChart";
      variables: GameControllerGetChartVariables;
    }
  | {
      path: "/game/free-spin-trigger";
      operationId: "gameControllerFreeSpinTriggger";
      variables: GameControllerFreeSpinTrigggerVariables;
    }
  | {
      path: "/game/user-profile";
      operationId: "gameControllerGetUserProfile";
      variables: GameControllerGetUserProfileVariables;
    }
  | {
      path: "/game/multiplayer-game-history";
      operationId: "gameControllerGetMultiplayerGameHistory";
      variables: GameControllerGetMultiplayerGameHistoryVariables;
    }
  | {
      path: "/game/live-wins";
      operationId: "gameControllerGetLiveWins";
      variables: GameControllerGetLiveWinsVariables;
    }
  | {
      path: "/game/live-big-wins";
      operationId: "gameControllerGetBigWins";
      variables: GameControllerGetBigWinsVariables;
    }
  | {
      path: "/game/live-lucky-wins";
      operationId: "gameControllerGetLiveLuckyWins";
      variables: GameControllerGetLiveLuckyWinsVariables;
    }
  | {
      path: "/game/lucky-wins";
      operationId: "gameControllerGetLuckyWins";
      variables: GameControllerGetLuckyWinsVariables;
    }
  | {
      path: "/game/top-bets";
      operationId: "gameControllerGetTopBets";
      variables: GameControllerGetTopBetsVariables;
    }
  | {
      path: "/game/stats-by-player";
      operationId: "gameControllerGetStatsByPlayer";
      variables: GameControllerGetStatsByPlayerVariables;
    }
  | {
      path: "/statistic/stats";
      operationId: "statisticControllerGetStats";
      variables: StatisticControllerGetStatsVariables;
    }
  | {
      path: "/statistic/mininig-stats";
      operationId: "statisticControllerGetMiningStats";
      variables: StatisticControllerGetMiningStatsVariables;
    }
  | {
      path: "/statistic/volume-leaderboard-list";
      operationId: "statisticControllerGetLeaderboardListByVolume";
      variables: StatisticControllerGetLeaderboardListByVolumeVariables;
    }
  | {
      path: "/statistic/profit-leaderboard-list";
      operationId: "statisticControllerGetLeaderboardListByProfit";
      variables: StatisticControllerGetLeaderboardListByProfitVariables;
    }
  | {
      path: "/statistic/lucky-leaderboard-list";
      operationId: "statisticControllerGetLeaderboardListByLuckyWinner";
      variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables;
    }
  | {
      path: "/bankroll/update-notify-single-sided-pools";
      operationId: "bankrollControllerUpdateSingleSidedPoolsNotify";
      variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables;
    }
  | {
      path: "/bankroll/single-sided-pools";
      operationId: "bankrollControllerGetSingleSidedPools";
      variables: BankrollControllerGetSingleSidedPoolsVariables;
    }
  | {
      path: "/bankroll/pool-list";
      operationId: "bankrollControllerGetPoolList";
      variables: BankrollControllerGetPoolListVariables;
    }
  | {
      path: "/referral/referral-history/{wallet}";
      operationId: "referralControllerGetReferralHistoryByPlayer";
      variables: ReferralControllerGetReferralHistoryByPlayerVariables;
    }
  | {
      path: "/referral/rewards-distribution-history/{wallet}";
      operationId: "referralControllerRewardsDistributionHistory";
      variables: ReferralControllerRewardsDistributionHistoryVariables;
    }
  | {
      path: "/referral/code-volume-and-rewards";
      operationId: "referralControllerCodesVolumeAndRewardAmounts";
      variables: ReferralControllerCodesVolumeAndRewardAmountsVariables;
    }
  | {
      path: "/stake/summary";
      operationId: "stakeControllerSummary";
      variables: StakeControllerSummaryVariables;
    };
