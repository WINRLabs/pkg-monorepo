/**
 * Generated by @openapi-codegen
 *
 * @version 2.0
 */
import * as reactQuery from '@tanstack/react-query';
import { useApiContext, ApiContext } from './apiContext';
import type * as Fetcher from './apiFetcher';
import { apiFetch } from './apiFetcher';
import type * as Schemas from './apiSchemas';

export type CurrencyControllerGetLastPriceFeedError = Fetcher.ErrorWrapper<undefined>;

export type CurrencyControllerGetLastPriceFeedResponse = Schemas.PriceResponse[];

export type CurrencyControllerGetLastPriceFeedVariables = ApiContext['fetcherOptions'];

export const fetchCurrencyControllerGetLastPriceFeed = (
  variables: CurrencyControllerGetLastPriceFeedVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    CurrencyControllerGetLastPriceFeedResponse,
    CurrencyControllerGetLastPriceFeedError,
    undefined,
    {},
    {},
    {}
  >({ url: '/currency/get-last-prices', method: 'get', ...variables, signal });

export const useCurrencyControllerGetLastPriceFeed = <
  TData = CurrencyControllerGetLastPriceFeedResponse,
>(
  variables: CurrencyControllerGetLastPriceFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CurrencyControllerGetLastPriceFeedResponse,
      CurrencyControllerGetLastPriceFeedError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    CurrencyControllerGetLastPriceFeedResponse,
    CurrencyControllerGetLastPriceFeedError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/currency/get-last-prices',
      operationId: 'currencyControllerGetLastPriceFeed',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCurrencyControllerGetLastPriceFeed({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerBetHistoryQueryParams = {
  game?:
    | 'COINFLIP'
    | 'RANGE'
    | 'WHEEL'
    | 'PLINKO'
    | 'MOON'
    | 'LOTTERY'
    | 'RPS'
    | 'DICE'
    | 'LIMBO'
    | 'SLOT'
    | 'ROULETTE'
    | 'MINES'
    | 'VIDEO_POKER'
    | 'KENO'
    | 'BACCARAT'
    | 'HORSE_RACE'
    | 'BLACKJACK'
    | 'HOLDEM_POKER'
    | 'WINR_BONANZA'
    | 'ONE_HAND_BLACKJACK';
  player?: string;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GameControllerBetHistoryError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerBetHistoryResponse = Schemas.PaginatedResonse & {
  data?: Schemas.GameResultDto[];
};

export type GameControllerBetHistoryVariables = {
  queryParams?: GameControllerBetHistoryQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerBetHistory = (
  variables: GameControllerBetHistoryVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerBetHistoryResponse,
    GameControllerBetHistoryError,
    undefined,
    {},
    GameControllerBetHistoryQueryParams,
    {}
  >({ url: '/game/bet-history', method: 'get', ...variables, signal });

export const useGameControllerBetHistory = <TData = GameControllerBetHistoryResponse,>(
  variables: GameControllerBetHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerBetHistoryResponse,
      GameControllerBetHistoryError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerBetHistoryResponse,
    GameControllerBetHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/bet-history',
      operationId: 'gameControllerBetHistory',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerBetHistory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGlobalBetHistoryError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGlobalBetHistoryResponse = Schemas.GameResultDto[];

export type GameControllerGlobalBetHistoryVariables = ApiContext['fetcherOptions'];

export const fetchGameControllerGlobalBetHistory = (
  variables: GameControllerGlobalBetHistoryVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGlobalBetHistoryResponse,
    GameControllerGlobalBetHistoryError,
    undefined,
    {},
    {},
    {}
  >({ url: '/game/global-bet-history', method: 'get', ...variables, signal });

export const useGameControllerGlobalBetHistory = <TData = GameControllerGlobalBetHistoryResponse,>(
  variables: GameControllerGlobalBetHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGlobalBetHistoryResponse,
      GameControllerGlobalBetHistoryError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGlobalBetHistoryResponse,
    GameControllerGlobalBetHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/global-bet-history',
      operationId: 'gameControllerGlobalBetHistory',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGlobalBetHistory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetChartQueryParams = {
  period: 'DAY' | 'WEEK' | 'MONTH' | 'UNRECOGNIZED';
};

export type GameControllerGetChartError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetChartResponse = Schemas.ChartObject[];

export type GameControllerGetChartVariables = {
  queryParams: GameControllerGetChartQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetChart = (
  variables: GameControllerGetChartVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetChartResponse,
    GameControllerGetChartError,
    undefined,
    {},
    GameControllerGetChartQueryParams,
    {}
  >({ url: '/game/chart', method: 'get', ...variables, signal });

export const useGameControllerGetChart = <TData = GameControllerGetChartResponse,>(
  variables: GameControllerGetChartVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GameControllerGetChartResponse, GameControllerGetChartError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<GameControllerGetChartResponse, GameControllerGetChartError, TData>({
    queryKey: queryKeyFn({ path: '/game/chart', operationId: 'gameControllerGetChart', variables }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetChart({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerFreeSpinTrigggerQueryParams = {
  player: string;
  token: string;
};

export type GameControllerFreeSpinTrigggerError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerFreeSpinTrigggerVariables = {
  queryParams: GameControllerFreeSpinTrigggerQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerFreeSpinTriggger = (
  variables: GameControllerFreeSpinTrigggerVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.TransactionResponse,
    GameControllerFreeSpinTrigggerError,
    undefined,
    {},
    GameControllerFreeSpinTrigggerQueryParams,
    {}
  >({ url: '/game/free-spin-trigger', method: 'get', ...variables, signal });

export const useGameControllerFreeSpinTriggger = <TData = Schemas.TransactionResponse,>(
  variables: GameControllerFreeSpinTrigggerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TransactionResponse,
      GameControllerFreeSpinTrigggerError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.TransactionResponse,
    GameControllerFreeSpinTrigggerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/free-spin-trigger',
      operationId: 'gameControllerFreeSpinTriggger',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerFreeSpinTriggger({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerAssignUsernameError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerAssignUsernameVariables = {
  body: Schemas.AssignUsernameInput;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerAssignUsername = (
  variables: GameControllerAssignUsernameVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.UsernameObject,
    GameControllerAssignUsernameError,
    Schemas.AssignUsernameInput,
    {},
    {},
    {}
  >({ url: '/game/assign-username', method: 'post', ...variables, signal });

export const useGameControllerAssignUsername = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsernameObject,
      GameControllerAssignUsernameError,
      GameControllerAssignUsernameVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UsernameObject,
    GameControllerAssignUsernameError,
    GameControllerAssignUsernameVariables
  >({
    mutationFn: (variables: GameControllerAssignUsernameVariables) =>
      fetchGameControllerAssignUsername({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GameControllerGetUserProfileQueryParams = {
  wallet: string;
};

export type GameControllerGetUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetUserProfileVariables = {
  queryParams: GameControllerGetUserProfileQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetUserProfile = (
  variables: GameControllerGetUserProfileVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.UsernameObject,
    GameControllerGetUserProfileError,
    undefined,
    {},
    GameControllerGetUserProfileQueryParams,
    {}
  >({ url: '/game/user-profile', method: 'get', ...variables, signal });

export const useGameControllerGetUserProfile = <TData = Schemas.UsernameObject,>(
  variables: GameControllerGetUserProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UsernameObject, GameControllerGetUserProfileError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.UsernameObject, GameControllerGetUserProfileError, TData>({
    queryKey: queryKeyFn({
      path: '/game/user-profile',
      operationId: 'gameControllerGetUserProfile',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetUserProfile({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetMultiplayerGameHistoryQueryParams = {
  game?:
    | 'COINFLIP'
    | 'RANGE'
    | 'WHEEL'
    | 'PLINKO'
    | 'MOON'
    | 'LOTTERY'
    | 'RPS'
    | 'DICE'
    | 'LIMBO'
    | 'SLOT'
    | 'ROULETTE'
    | 'MINES'
    | 'VIDEO_POKER'
    | 'KENO'
    | 'BACCARAT'
    | 'HORSE_RACE'
    | 'BLACKJACK'
    | 'HOLDEM_POKER'
    | 'WINR_BONANZA'
    | 'ONE_HAND_BLACKJACK';
};

export type GameControllerGetMultiplayerGameHistoryError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetMultiplayerGameHistoryResponse =
  Schemas.MultiplayerGameHistoryObject[];

export type GameControllerGetMultiplayerGameHistoryVariables = {
  queryParams?: GameControllerGetMultiplayerGameHistoryQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetMultiplayerGameHistory = (
  variables: GameControllerGetMultiplayerGameHistoryVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetMultiplayerGameHistoryResponse,
    GameControllerGetMultiplayerGameHistoryError,
    undefined,
    {},
    GameControllerGetMultiplayerGameHistoryQueryParams,
    {}
  >({ url: '/game/multiplayer-game-history', method: 'get', ...variables, signal });

export const useGameControllerGetMultiplayerGameHistory = <
  TData = GameControllerGetMultiplayerGameHistoryResponse,
>(
  variables: GameControllerGetMultiplayerGameHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetMultiplayerGameHistoryResponse,
      GameControllerGetMultiplayerGameHistoryError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetMultiplayerGameHistoryResponse,
    GameControllerGetMultiplayerGameHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/multiplayer-game-history',
      operationId: 'gameControllerGetMultiplayerGameHistory',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetMultiplayerGameHistory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLiveWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLiveWinsResponse = Schemas.LiveWinsDto[];

export type GameControllerGetLiveWinsVariables = ApiContext['fetcherOptions'];

export const fetchGameControllerGetLiveWins = (
  variables: GameControllerGetLiveWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetLiveWinsResponse,
    GameControllerGetLiveWinsError,
    undefined,
    {},
    {},
    {}
  >({ url: '/game/live-wins', method: 'get', ...variables, signal });

export const useGameControllerGetLiveWins = <TData = GameControllerGetLiveWinsResponse,>(
  variables: GameControllerGetLiveWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLiveWinsResponse,
      GameControllerGetLiveWinsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLiveWinsResponse,
    GameControllerGetLiveWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/live-wins',
      operationId: 'gameControllerGetLiveWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLiveWins({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetBigWinsQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
};

export type GameControllerGetBigWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetBigWinsResponse = Schemas.BigWinsDto[];

export type GameControllerGetBigWinsVariables = {
  queryParams?: GameControllerGetBigWinsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetBigWins = (
  variables: GameControllerGetBigWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetBigWinsResponse,
    GameControllerGetBigWinsError,
    undefined,
    {},
    GameControllerGetBigWinsQueryParams,
    {}
  >({ url: '/game/live-big-wins', method: 'get', ...variables, signal });

export const useGameControllerGetBigWins = <TData = GameControllerGetBigWinsResponse,>(
  variables: GameControllerGetBigWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetBigWinsResponse,
      GameControllerGetBigWinsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetBigWinsResponse,
    GameControllerGetBigWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/live-big-wins',
      operationId: 'gameControllerGetBigWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetBigWins({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLiveLuckyWinsQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
};

export type GameControllerGetLiveLuckyWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLiveLuckyWinsResponse = Schemas.LuckyWinsDto[];

export type GameControllerGetLiveLuckyWinsVariables = {
  queryParams?: GameControllerGetLiveLuckyWinsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetLiveLuckyWins = (
  variables: GameControllerGetLiveLuckyWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetLiveLuckyWinsResponse,
    GameControllerGetLiveLuckyWinsError,
    undefined,
    {},
    GameControllerGetLiveLuckyWinsQueryParams,
    {}
  >({ url: '/game/live-lucky-wins', method: 'get', ...variables, signal });

export const useGameControllerGetLiveLuckyWins = <TData = GameControllerGetLiveLuckyWinsResponse,>(
  variables: GameControllerGetLiveLuckyWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLiveLuckyWinsResponse,
      GameControllerGetLiveLuckyWinsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLiveLuckyWinsResponse,
    GameControllerGetLiveLuckyWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/live-lucky-wins',
      operationId: 'gameControllerGetLiveLuckyWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLiveLuckyWins({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetLuckyWinsQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  wallet: string;
};

export type GameControllerGetLuckyWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetLuckyWinsResponse = Schemas.PaginatedResonse & {
  data?: Schemas.LuckyWinsDto[];
};

export type GameControllerGetLuckyWinsVariables = {
  queryParams: GameControllerGetLuckyWinsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetLuckyWins = (
  variables: GameControllerGetLuckyWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetLuckyWinsResponse,
    GameControllerGetLuckyWinsError,
    undefined,
    {},
    GameControllerGetLuckyWinsQueryParams,
    {}
  >({ url: '/game/lucky-wins', method: 'get', ...variables, signal });

export const useGameControllerGetLuckyWins = <TData = GameControllerGetLuckyWinsResponse,>(
  variables: GameControllerGetLuckyWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetLuckyWinsResponse,
      GameControllerGetLuckyWinsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetLuckyWinsResponse,
    GameControllerGetLuckyWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/lucky-wins',
      operationId: 'gameControllerGetLuckyWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetLuckyWins({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetTopBetsQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  wallet: string;
};

export type GameControllerGetTopBetsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetTopBetsResponse = Schemas.PaginatedResonse & {
  data?: Schemas.LuckyWinsDto[];
};

export type GameControllerGetTopBetsVariables = {
  queryParams: GameControllerGetTopBetsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetTopBets = (
  variables: GameControllerGetTopBetsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    GameControllerGetTopBetsResponse,
    GameControllerGetTopBetsError,
    undefined,
    {},
    GameControllerGetTopBetsQueryParams,
    {}
  >({ url: '/game/top-bets', method: 'get', ...variables, signal });

export const useGameControllerGetTopBets = <TData = GameControllerGetTopBetsResponse,>(
  variables: GameControllerGetTopBetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GameControllerGetTopBetsResponse,
      GameControllerGetTopBetsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    GameControllerGetTopBetsResponse,
    GameControllerGetTopBetsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/game/top-bets',
      operationId: 'gameControllerGetTopBets',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetTopBets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerGetStatsByPlayerQueryParams = {
  wallet: string;
};

export type GameControllerGetStatsByPlayerError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerGetStatsByPlayerVariables = {
  queryParams: GameControllerGetStatsByPlayerQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchGameControllerGetStatsByPlayer = (
  variables: GameControllerGetStatsByPlayerVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.PlayerRankObject,
    GameControllerGetStatsByPlayerError,
    undefined,
    {},
    GameControllerGetStatsByPlayerQueryParams,
    {}
  >({ url: '/game/stats-by-player', method: 'get', ...variables, signal });

export const useGameControllerGetStatsByPlayer = <TData = Schemas.PlayerRankObject,>(
  variables: GameControllerGetStatsByPlayerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlayerRankObject,
      GameControllerGetStatsByPlayerError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.PlayerRankObject, GameControllerGetStatsByPlayerError, TData>({
    queryKey: queryKeyFn({
      path: '/game/stats-by-player',
      operationId: 'gameControllerGetStatsByPlayer',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerGetStatsByPlayer({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GameControllerSseLiveWinsError = Fetcher.ErrorWrapper<undefined>;

export type GameControllerSseLiveWinsVariables = ApiContext['fetcherOptions'];

export const fetchGameControllerSseLiveWins = (
  variables: GameControllerSseLiveWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<undefined, GameControllerSseLiveWinsError, undefined, {}, {}, {}>({
    url: '/game/sse-live-wins',
    method: 'get',
    ...variables,
    signal,
  });

export const useGameControllerSseLiveWins = <TData = undefined,>(
  variables: GameControllerSseLiveWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GameControllerSseLiveWinsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<undefined, GameControllerSseLiveWinsError, TData>({
    queryKey: queryKeyFn({
      path: '/game/sse-live-wins',
      operationId: 'gameControllerSseLiveWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGameControllerSseLiveWins({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type RefundControllerRefundGameError = Fetcher.ErrorWrapper<undefined>;

export type RefundControllerRefundGameVariables = {
  body: Schemas.RefundInput;
} & ApiContext['fetcherOptions'];

export const fetchRefundControllerRefundGame = (
  variables: RefundControllerRefundGameVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.TransactionResponse,
    RefundControllerRefundGameError,
    Schemas.RefundInput,
    {},
    {},
    {}
  >({ url: '/refund/refund-game', method: 'post', ...variables, signal });

export const useRefundControllerRefundGame = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TransactionResponse,
      RefundControllerRefundGameError,
      RefundControllerRefundGameVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.TransactionResponse,
    RefundControllerRefundGameError,
    RefundControllerRefundGameVariables
  >({
    mutationFn: (variables: RefundControllerRefundGameVariables) =>
      fetchRefundControllerRefundGame({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RefundControllerReIterateError = Fetcher.ErrorWrapper<undefined>;

export type RefundControllerReIterateVariables = {
  body: Schemas.RefundInput;
} & ApiContext['fetcherOptions'];

export const fetchRefundControllerReIterate = (
  variables: RefundControllerReIterateVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.TransactionResponse,
    RefundControllerReIterateError,
    Schemas.RefundInput,
    {},
    {},
    {}
  >({ url: '/refund/re-iterate', method: 'post', ...variables, signal });

export const useRefundControllerReIterate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TransactionResponse,
      RefundControllerReIterateError,
      RefundControllerReIterateVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.TransactionResponse,
    RefundControllerReIterateError,
    RefundControllerReIterateVariables
  >({
    mutationFn: (variables: RefundControllerReIterateVariables) =>
      fetchRefundControllerReIterate({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StatisticControllerGetStatsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetStatsVariables = ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetStats = (
  variables: StatisticControllerGetStatsVariables,
  signal?: AbortSignal
) =>
  apiFetch<Schemas.JustBetStats, StatisticControllerGetStatsError, undefined, {}, {}, {}>({
    url: '/statistic/stats',
    method: 'get',
    ...variables,
    signal,
  });

export const useStatisticControllerGetStats = <TData = Schemas.JustBetStats,>(
  variables: StatisticControllerGetStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.JustBetStats, StatisticControllerGetStatsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.JustBetStats, StatisticControllerGetStatsError, TData>({
    queryKey: queryKeyFn({
      path: '/statistic/stats',
      operationId: 'statisticControllerGetStats',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetStats({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetMiningStatsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetMiningStatsVariables = ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetMiningStats = (
  variables: StatisticControllerGetMiningStatsVariables,
  signal?: AbortSignal
) =>
  apiFetch<Schemas.MiningStatistics, StatisticControllerGetMiningStatsError, undefined, {}, {}, {}>(
    { url: '/statistic/mininig-stats', method: 'get', ...variables, signal }
  );

export const useStatisticControllerGetMiningStats = <TData = Schemas.MiningStatistics,>(
  variables: StatisticControllerGetMiningStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MiningStatistics,
      StatisticControllerGetMiningStatsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.MiningStatistics,
    StatisticControllerGetMiningStatsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/mininig-stats',
      operationId: 'statisticControllerGetMiningStats',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetMiningStats({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetDashboardStatsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetDashboardStatsVariables = ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetDashboardStats = (
  variables: StatisticControllerGetDashboardStatsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.DashboardStats,
    StatisticControllerGetDashboardStatsError,
    undefined,
    {},
    {},
    {}
  >({ url: '/statistic/dashboard-stats', method: 'get', ...variables, signal });

export const useStatisticControllerGetDashboardStats = <TData = Schemas.DashboardStats,>(
  variables: StatisticControllerGetDashboardStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DashboardStats,
      StatisticControllerGetDashboardStatsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.DashboardStats,
    StatisticControllerGetDashboardStatsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/dashboard-stats',
      operationId: 'statisticControllerGetDashboardStats',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetDashboardStats({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByVolumeQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
  sortBy?: 'WON' | 'BET' | 'WINRATE' | 'VOLUME' | 'PROFIT' | 'MULTIPLIER';
  sortOrder?: 'ASC' | 'DESC';
  /**
   * The player address to filter the leaderboard by
   */
  playerAddress?: string | null;
};

export type StatisticControllerGetLeaderboardListByVolumeError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByVolumeVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByVolumeQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetLeaderboardListByVolume = (
  variables: StatisticControllerGetLeaderboardListByVolumeVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.LeaderboardVolumeResponse,
    StatisticControllerGetLeaderboardListByVolumeError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByVolumeQueryParams,
    {}
  >({ url: '/statistic/volume-leaderboard-list', method: 'get', ...variables, signal });

export const useStatisticControllerGetLeaderboardListByVolume = <
  TData = Schemas.LeaderboardVolumeResponse,
>(
  variables: StatisticControllerGetLeaderboardListByVolumeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LeaderboardVolumeResponse,
      StatisticControllerGetLeaderboardListByVolumeError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.LeaderboardVolumeResponse,
    StatisticControllerGetLeaderboardListByVolumeError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/volume-leaderboard-list',
      operationId: 'statisticControllerGetLeaderboardListByVolume',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByVolume(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByProfitQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
  sortBy?: 'WON' | 'BET' | 'WINRATE' | 'VOLUME' | 'PROFIT' | 'MULTIPLIER';
  sortOrder?: 'ASC' | 'DESC';
  /**
   * The player address to filter the leaderboard by
   */
  playerAddress?: string | null;
};

export type StatisticControllerGetLeaderboardListByProfitError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByProfitVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByProfitQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetLeaderboardListByProfit = (
  variables: StatisticControllerGetLeaderboardListByProfitVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.LeaderboardProfitResponse,
    StatisticControllerGetLeaderboardListByProfitError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByProfitQueryParams,
    {}
  >({ url: '/statistic/profit-leaderboard-list', method: 'get', ...variables, signal });

export const useStatisticControllerGetLeaderboardListByProfit = <
  TData = Schemas.LeaderboardProfitResponse,
>(
  variables: StatisticControllerGetLeaderboardListByProfitVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LeaderboardProfitResponse,
      StatisticControllerGetLeaderboardListByProfitError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.LeaderboardProfitResponse,
    StatisticControllerGetLeaderboardListByProfitError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/profit-leaderboard-list',
      operationId: 'statisticControllerGetLeaderboardListByProfit',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByProfit(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
  sortBy?: 'WON' | 'BET' | 'WINRATE' | 'VOLUME' | 'PROFIT' | 'MULTIPLIER';
  sortOrder?: 'ASC' | 'DESC';
  /**
   * The player address to filter the leaderboard by
   */
  playerAddress?: string | null;
};

export type StatisticControllerGetLeaderboardListByLuckyWinnerError =
  Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListByLuckyWinnerResponse =
  Schemas.LeaderboardLuckyWinnerObject[];

export type StatisticControllerGetLeaderboardListByLuckyWinnerVariables = {
  queryParams?: StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetLeaderboardListByLuckyWinner = (
  variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
    StatisticControllerGetLeaderboardListByLuckyWinnerError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListByLuckyWinnerQueryParams,
    {}
  >({ url: '/statistic/lucky-leaderboard-list', method: 'get', ...variables, signal });

export const useStatisticControllerGetLeaderboardListByLuckyWinner = <
  TData = StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
>(
  variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
      StatisticControllerGetLeaderboardListByLuckyWinnerError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    StatisticControllerGetLeaderboardListByLuckyWinnerResponse,
    StatisticControllerGetLeaderboardListByLuckyWinnerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/lucky-leaderboard-list',
      operationId: 'statisticControllerGetLeaderboardListByLuckyWinner',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListByLuckyWinner(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListBigWinsQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
  sortBy?: 'WON' | 'BET' | 'WINRATE' | 'VOLUME' | 'PROFIT' | 'MULTIPLIER';
  sortOrder?: 'ASC' | 'DESC';
  /**
   * The player address to filter the leaderboard by
   */
  playerAddress?: string | null;
};

export type StatisticControllerGetLeaderboardListBigWinsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListBigWinsResponse =
  Schemas.LeaderboardBigWinsObject[];

export type StatisticControllerGetLeaderboardListBigWinsVariables = {
  queryParams?: StatisticControllerGetLeaderboardListBigWinsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetLeaderboardListBigWins = (
  variables: StatisticControllerGetLeaderboardListBigWinsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    StatisticControllerGetLeaderboardListBigWinsResponse,
    StatisticControllerGetLeaderboardListBigWinsError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListBigWinsQueryParams,
    {}
  >({ url: '/statistic/bigwins-leaderboard-list', method: 'get', ...variables, signal });

export const useStatisticControllerGetLeaderboardListBigWins = <
  TData = StatisticControllerGetLeaderboardListBigWinsResponse,
>(
  variables: StatisticControllerGetLeaderboardListBigWinsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StatisticControllerGetLeaderboardListBigWinsResponse,
      StatisticControllerGetLeaderboardListBigWinsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    StatisticControllerGetLeaderboardListBigWinsResponse,
    StatisticControllerGetLeaderboardListBigWinsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/bigwins-leaderboard-list',
      operationId: 'statisticControllerGetLeaderboardListBigWins',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListBigWins(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type StatisticControllerGetLeaderboardListLossLegendsQueryParams = {
  period?: 'ALLTIME' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
  sortBy?: 'WON' | 'BET' | 'WINRATE' | 'VOLUME' | 'PROFIT' | 'MULTIPLIER';
  sortOrder?: 'ASC' | 'DESC';
  /**
   * The player address to filter the leaderboard by
   */
  playerAddress?: string | null;
};

export type StatisticControllerGetLeaderboardListLossLegendsError = Fetcher.ErrorWrapper<undefined>;

export type StatisticControllerGetLeaderboardListLossLegendsVariables = {
  queryParams?: StatisticControllerGetLeaderboardListLossLegendsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchStatisticControllerGetLeaderboardListLossLegends = (
  variables: StatisticControllerGetLeaderboardListLossLegendsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.LeaderboardLossLegendsResponse,
    StatisticControllerGetLeaderboardListLossLegendsError,
    undefined,
    {},
    StatisticControllerGetLeaderboardListLossLegendsQueryParams,
    {}
  >({ url: '/statistic/loss-legends-leaderboard-list', method: 'get', ...variables, signal });

export const useStatisticControllerGetLeaderboardListLossLegends = <
  TData = Schemas.LeaderboardLossLegendsResponse,
>(
  variables: StatisticControllerGetLeaderboardListLossLegendsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LeaderboardLossLegendsResponse,
      StatisticControllerGetLeaderboardListLossLegendsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.LeaderboardLossLegendsResponse,
    StatisticControllerGetLeaderboardListLossLegendsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/statistic/loss-legends-leaderboard-list',
      operationId: 'statisticControllerGetLeaderboardListLossLegends',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStatisticControllerGetLeaderboardListLossLegends(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams = {
  /**
   * comma separated
   */
  bankrollIndexes: string;
};

export type BankrollControllerUpdateSingleSidedPoolsNotifyError = Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerUpdateSingleSidedPoolsNotifyVariables = {
  queryParams: BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchBankrollControllerUpdateSingleSidedPoolsNotify = (
  variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    BankrollControllerUpdateSingleSidedPoolsNotifyError,
    undefined,
    {},
    BankrollControllerUpdateSingleSidedPoolsNotifyQueryParams,
    {}
  >({ url: '/bankroll/update-notify-single-sided-pools', method: 'get', ...variables, signal });

export const useBankrollControllerUpdateSingleSidedPoolsNotify = <TData = undefined,>(
  variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      BankrollControllerUpdateSingleSidedPoolsNotifyError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<undefined, BankrollControllerUpdateSingleSidedPoolsNotifyError, TData>(
    {
      queryKey: queryKeyFn({
        path: '/bankroll/update-notify-single-sided-pools',
        operationId: 'bankrollControllerUpdateSingleSidedPoolsNotify',
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchBankrollControllerUpdateSingleSidedPoolsNotify(
          { ...fetcherOptions, ...variables },
          signal
        ),
      ...options,
      ...queryOptions,
    }
  );
};

export type BankrollControllerGetWagerInfoError = Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerGetWagerInfoResponse = Schemas.WagerResponse[];

export type BankrollControllerGetWagerInfoVariables = ApiContext['fetcherOptions'];

export const fetchBankrollControllerGetWagerInfo = (
  variables: BankrollControllerGetWagerInfoVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    BankrollControllerGetWagerInfoResponse,
    BankrollControllerGetWagerInfoError,
    undefined,
    {},
    {},
    {}
  >({ url: '/bankroll/wager-info', method: 'get', ...variables, signal });

export const useBankrollControllerGetWagerInfo = <TData = BankrollControllerGetWagerInfoResponse,>(
  variables: BankrollControllerGetWagerInfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BankrollControllerGetWagerInfoResponse,
      BankrollControllerGetWagerInfoError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    BankrollControllerGetWagerInfoResponse,
    BankrollControllerGetWagerInfoError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/bankroll/wager-info',
      operationId: 'bankrollControllerGetWagerInfo',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerGetWagerInfo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerGetSingleSidedPoolsQueryParams = {
  /**
   * comma separated
   */
  bankrollIndexes: string;
  player?: string;
};

export type BankrollControllerGetSingleSidedPoolsError = Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerGetSingleSidedPoolsResponse = Schemas.VaultOutput[];

export type BankrollControllerGetSingleSidedPoolsVariables = {
  queryParams: BankrollControllerGetSingleSidedPoolsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchBankrollControllerGetSingleSidedPools = (
  variables: BankrollControllerGetSingleSidedPoolsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    BankrollControllerGetSingleSidedPoolsResponse,
    BankrollControllerGetSingleSidedPoolsError,
    undefined,
    {},
    BankrollControllerGetSingleSidedPoolsQueryParams,
    {}
  >({ url: '/bankroll/single-sided-pools', method: 'get', ...variables, signal });

export const useBankrollControllerGetSingleSidedPools = <
  TData = BankrollControllerGetSingleSidedPoolsResponse,
>(
  variables: BankrollControllerGetSingleSidedPoolsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BankrollControllerGetSingleSidedPoolsResponse,
      BankrollControllerGetSingleSidedPoolsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    BankrollControllerGetSingleSidedPoolsResponse,
    BankrollControllerGetSingleSidedPoolsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/bankroll/single-sided-pools',
      operationId: 'bankrollControllerGetSingleSidedPools',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerGetSingleSidedPools({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type BankrollControllerGetPoolListError = Fetcher.ErrorWrapper<undefined>;

export type BankrollControllerGetPoolListResponse = Schemas.PoolOutput[];

export type BankrollControllerGetPoolListVariables = ApiContext['fetcherOptions'];

export const fetchBankrollControllerGetPoolList = (
  variables: BankrollControllerGetPoolListVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    BankrollControllerGetPoolListResponse,
    BankrollControllerGetPoolListError,
    undefined,
    {},
    {},
    {}
  >({ url: '/bankroll/pool-list', method: 'get', ...variables, signal });

export const useBankrollControllerGetPoolList = <TData = BankrollControllerGetPoolListResponse,>(
  variables: BankrollControllerGetPoolListVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BankrollControllerGetPoolListResponse,
      BankrollControllerGetPoolListError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    BankrollControllerGetPoolListResponse,
    BankrollControllerGetPoolListError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/bankroll/pool-list',
      operationId: 'bankrollControllerGetPoolList',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchBankrollControllerGetPoolList({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerGetReferralHistoryByPlayerPathParams = {
  /**
   * User wallet address
   */
  wallet: string;
};

export type ReferralControllerGetReferralHistoryByPlayerQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type ReferralControllerGetReferralHistoryByPlayerError = Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerGetReferralHistoryByPlayerResponse = Schemas.PaginatedResonse & {
  data?: Schemas.ReferralRewardEntity[];
};

export type ReferralControllerGetReferralHistoryByPlayerVariables = {
  pathParams: ReferralControllerGetReferralHistoryByPlayerPathParams;
  queryParams?: ReferralControllerGetReferralHistoryByPlayerQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchReferralControllerGetReferralHistoryByPlayer = (
  variables: ReferralControllerGetReferralHistoryByPlayerVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    ReferralControllerGetReferralHistoryByPlayerResponse,
    ReferralControllerGetReferralHistoryByPlayerError,
    undefined,
    {},
    ReferralControllerGetReferralHistoryByPlayerQueryParams,
    ReferralControllerGetReferralHistoryByPlayerPathParams
  >({ url: '/referral/referral-history/{wallet}', method: 'get', ...variables, signal });

export const useReferralControllerGetReferralHistoryByPlayer = <
  TData = ReferralControllerGetReferralHistoryByPlayerResponse,
>(
  variables: ReferralControllerGetReferralHistoryByPlayerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerGetReferralHistoryByPlayerResponse,
      ReferralControllerGetReferralHistoryByPlayerError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerGetReferralHistoryByPlayerResponse,
    ReferralControllerGetReferralHistoryByPlayerError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/referral/referral-history/{wallet}',
      operationId: 'referralControllerGetReferralHistoryByPlayer',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerGetReferralHistoryByPlayer(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerRewardsDistributionHistoryPathParams = {
  /**
   * User wallet address
   */
  wallet: string;
};

export type ReferralControllerRewardsDistributionHistoryQueryParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type ReferralControllerRewardsDistributionHistoryError = Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerRewardsDistributionHistoryResponse = Schemas.PaginatedResonse & {
  data?: Schemas.ReferralClaimEntity[];
};

export type ReferralControllerRewardsDistributionHistoryVariables = {
  pathParams: ReferralControllerRewardsDistributionHistoryPathParams;
  queryParams?: ReferralControllerRewardsDistributionHistoryQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchReferralControllerRewardsDistributionHistory = (
  variables: ReferralControllerRewardsDistributionHistoryVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    ReferralControllerRewardsDistributionHistoryResponse,
    ReferralControllerRewardsDistributionHistoryError,
    undefined,
    {},
    ReferralControllerRewardsDistributionHistoryQueryParams,
    ReferralControllerRewardsDistributionHistoryPathParams
  >({
    url: '/referral/rewards-distribution-history/{wallet}',
    method: 'get',
    ...variables,
    signal,
  });

export const useReferralControllerRewardsDistributionHistory = <
  TData = ReferralControllerRewardsDistributionHistoryResponse,
>(
  variables: ReferralControllerRewardsDistributionHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerRewardsDistributionHistoryResponse,
      ReferralControllerRewardsDistributionHistoryError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerRewardsDistributionHistoryResponse,
    ReferralControllerRewardsDistributionHistoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/referral/rewards-distribution-history/{wallet}',
      operationId: 'referralControllerRewardsDistributionHistory',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerRewardsDistributionHistory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReferralControllerCodesVolumeAndRewardAmountsQueryParams = {
  codes: string;
};

export type ReferralControllerCodesVolumeAndRewardAmountsError = Fetcher.ErrorWrapper<undefined>;

export type ReferralControllerCodesVolumeAndRewardAmountsResponse = Schemas.CodesVolumeAndReward[];

export type ReferralControllerCodesVolumeAndRewardAmountsVariables = {
  queryParams: ReferralControllerCodesVolumeAndRewardAmountsQueryParams;
} & ApiContext['fetcherOptions'];

export const fetchReferralControllerCodesVolumeAndRewardAmounts = (
  variables: ReferralControllerCodesVolumeAndRewardAmountsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    ReferralControllerCodesVolumeAndRewardAmountsResponse,
    ReferralControllerCodesVolumeAndRewardAmountsError,
    undefined,
    {},
    ReferralControllerCodesVolumeAndRewardAmountsQueryParams,
    {}
  >({ url: '/referral/code-volume-and-rewards', method: 'get', ...variables, signal });

export const useReferralControllerCodesVolumeAndRewardAmounts = <
  TData = ReferralControllerCodesVolumeAndRewardAmountsResponse,
>(
  variables: ReferralControllerCodesVolumeAndRewardAmountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReferralControllerCodesVolumeAndRewardAmountsResponse,
      ReferralControllerCodesVolumeAndRewardAmountsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    ReferralControllerCodesVolumeAndRewardAmountsResponse,
    ReferralControllerCodesVolumeAndRewardAmountsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/referral/code-volume-and-rewards',
      operationId: 'referralControllerCodesVolumeAndRewardAmounts',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReferralControllerCodesVolumeAndRewardAmounts(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type BadgeControllerAwardBadgeError = Fetcher.ErrorWrapper<undefined>;

export type BadgeControllerAwardBadgeVariables = {
  body: Schemas.AwardBadge;
} & ApiContext['fetcherOptions'];

export const fetchBadgeControllerAwardBadge = (
  variables: BadgeControllerAwardBadgeVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.AwardBadgeResponse,
    BadgeControllerAwardBadgeError,
    Schemas.AwardBadge,
    {},
    {},
    {}
  >({ url: '/badge/award', method: 'post', ...variables, signal });

export const useBadgeControllerAwardBadge = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AwardBadgeResponse,
      BadgeControllerAwardBadgeError,
      BadgeControllerAwardBadgeVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.AwardBadgeResponse,
    BadgeControllerAwardBadgeError,
    BadgeControllerAwardBadgeVariables
  >({
    mutationFn: (variables: BadgeControllerAwardBadgeVariables) =>
      fetchBadgeControllerAwardBadge({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BadgeControllerWeeklyClaimerError = Fetcher.ErrorWrapper<undefined>;

export type BadgeControllerWeeklyClaimerVariables = {
  body: Schemas.WeeklyClaimer;
} & ApiContext['fetcherOptions'];

export const fetchBadgeControllerWeeklyClaimer = (
  variables: BadgeControllerWeeklyClaimerVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.BadgeResponse,
    BadgeControllerWeeklyClaimerError,
    Schemas.WeeklyClaimer,
    {},
    {},
    {}
  >({ url: '/badge/weekly-claimer', method: 'post', ...variables, signal });

export const useBadgeControllerWeeklyClaimer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BadgeResponse,
      BadgeControllerWeeklyClaimerError,
      BadgeControllerWeeklyClaimerVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BadgeResponse,
    BadgeControllerWeeklyClaimerError,
    BadgeControllerWeeklyClaimerVariables
  >({
    mutationFn: (variables: BadgeControllerWeeklyClaimerVariables) =>
      fetchBadgeControllerWeeklyClaimer({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type StakeControllerSummaryError = Fetcher.ErrorWrapper<undefined>;

export type StakeControllerSummaryVariables = ApiContext['fetcherOptions'];

export const fetchStakeControllerSummary = (
  variables: StakeControllerSummaryVariables,
  signal?: AbortSignal
) =>
  apiFetch<Schemas.SummaryResponse, StakeControllerSummaryError, undefined, {}, {}, {}>({
    url: '/stake/summary',
    method: 'get',
    ...variables,
    signal,
  });

export const useStakeControllerSummary = <TData = Schemas.SummaryResponse,>(
  variables: StakeControllerSummaryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.SummaryResponse, StakeControllerSummaryError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.SummaryResponse, StakeControllerSummaryError, TData>({
    queryKey: queryKeyFn({
      path: '/stake/summary',
      operationId: 'stakeControllerSummary',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchStakeControllerSummary({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type RankControllerTakeLevelupSnapshotError = Fetcher.ErrorWrapper<undefined>;

export type RankControllerTakeLevelupSnapshotVariables = {
  body: Schemas.TakeLevelupSnapshotInput;
} & ApiContext['fetcherOptions'];

export const fetchRankControllerTakeLevelupSnapshot = (
  variables: RankControllerTakeLevelupSnapshotVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    RankControllerTakeLevelupSnapshotError,
    Schemas.TakeLevelupSnapshotInput,
    {},
    {},
    {}
  >({ url: '/rank/take-levelup-snapshot', method: 'post', ...variables, signal });

export const useRankControllerTakeLevelupSnapshot = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RankControllerTakeLevelupSnapshotError,
      RankControllerTakeLevelupSnapshotVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    RankControllerTakeLevelupSnapshotError,
    RankControllerTakeLevelupSnapshotVariables
  >({
    mutationFn: (variables: RankControllerTakeLevelupSnapshotVariables) =>
      fetchRankControllerTakeLevelupSnapshot({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BridgeControllerDepositError = Fetcher.ErrorWrapper<undefined>;

export type BridgeControllerDepositVariables = {
  body: Schemas.BridgeDepositDto;
} & ApiContext['fetcherOptions'];

export const fetchBridgeControllerDeposit = (
  variables: BridgeControllerDepositVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.BridgeDepositDto,
    BridgeControllerDepositError,
    Schemas.BridgeDepositDto,
    {},
    {},
    {}
  >({ url: '/deposit', method: 'post', ...variables, signal });

export const useBridgeControllerDeposit = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BridgeDepositDto,
      BridgeControllerDepositError,
      BridgeControllerDepositVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BridgeDepositDto,
    BridgeControllerDepositError,
    BridgeControllerDepositVariables
  >({
    mutationFn: (variables: BridgeControllerDepositVariables) =>
      fetchBridgeControllerDeposit({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BridgeControllerWithdrawError = Fetcher.ErrorWrapper<undefined>;

export type BridgeControllerWithdrawVariables = {
  body: Schemas.BridgeWithdrawDto;
} & ApiContext['fetcherOptions'];

export const fetchBridgeControllerWithdraw = (
  variables: BridgeControllerWithdrawVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.BridgeWithdrawDto,
    BridgeControllerWithdrawError,
    Schemas.BridgeWithdrawDto,
    {},
    {},
    {}
  >({ url: '/withdraw', method: 'post', ...variables, signal });

export const useBridgeControllerWithdraw = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BridgeWithdrawDto,
      BridgeControllerWithdrawError,
      BridgeControllerWithdrawVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BridgeWithdrawDto,
    BridgeControllerWithdrawError,
    BridgeControllerWithdrawVariables
  >({
    mutationFn: (variables: BridgeControllerWithdrawVariables) =>
      fetchBridgeControllerWithdraw({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type BridgeControllerHistoryPathParams = {
  player: string;
};

export type BridgeControllerHistoryError = Fetcher.ErrorWrapper<undefined>;

export type BridgeControllerHistoryResponse = any[];

export type BridgeControllerHistoryVariables = {
  pathParams: BridgeControllerHistoryPathParams;
} & ApiContext['fetcherOptions'];

export const fetchBridgeControllerHistory = (
  variables: BridgeControllerHistoryVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    BridgeControllerHistoryResponse,
    BridgeControllerHistoryError,
    undefined,
    {},
    {},
    BridgeControllerHistoryPathParams
  >({ url: '/history', method: 'get', ...variables, signal });

export const useBridgeControllerHistory = <TData = BridgeControllerHistoryResponse,>(
  variables: BridgeControllerHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      BridgeControllerHistoryResponse,
      BridgeControllerHistoryError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<BridgeControllerHistoryResponse, BridgeControllerHistoryError, TData>({
    queryKey: queryKeyFn({ path: '/history', operationId: 'bridgeControllerHistory', variables }),
    queryFn: ({ signal }) =>
      fetchBridgeControllerHistory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type BridgeControllerLatestPathParams = {
  player: string;
};

export type BridgeControllerLatestError = Fetcher.ErrorWrapper<undefined>;

export type BridgeControllerLatestVariables = {
  pathParams: BridgeControllerLatestPathParams;
} & ApiContext['fetcherOptions'];

export const fetchBridgeControllerLatest = (
  variables: BridgeControllerLatestVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.BridgeHistoryResponse,
    BridgeControllerLatestError,
    undefined,
    {},
    {},
    BridgeControllerLatestPathParams
  >({ url: '/latest', method: 'get', ...variables, signal });

export const useBridgeControllerLatest = <TData = Schemas.BridgeHistoryResponse,>(
  variables: BridgeControllerLatestVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.BridgeHistoryResponse, BridgeControllerLatestError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.BridgeHistoryResponse, BridgeControllerLatestError, TData>({
    queryKey: queryKeyFn({ path: '/latest', operationId: 'bridgeControllerLatest', variables }),
    queryFn: ({ signal }) =>
      fetchBridgeControllerLatest({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: '/currency/get-last-prices';
      operationId: 'currencyControllerGetLastPriceFeed';
      variables: CurrencyControllerGetLastPriceFeedVariables;
    }
  | {
      path: '/game/bet-history';
      operationId: 'gameControllerBetHistory';
      variables: GameControllerBetHistoryVariables;
    }
  | {
      path: '/game/global-bet-history';
      operationId: 'gameControllerGlobalBetHistory';
      variables: GameControllerGlobalBetHistoryVariables;
    }
  | {
      path: '/game/chart';
      operationId: 'gameControllerGetChart';
      variables: GameControllerGetChartVariables;
    }
  | {
      path: '/game/free-spin-trigger';
      operationId: 'gameControllerFreeSpinTriggger';
      variables: GameControllerFreeSpinTrigggerVariables;
    }
  | {
      path: '/game/user-profile';
      operationId: 'gameControllerGetUserProfile';
      variables: GameControllerGetUserProfileVariables;
    }
  | {
      path: '/game/multiplayer-game-history';
      operationId: 'gameControllerGetMultiplayerGameHistory';
      variables: GameControllerGetMultiplayerGameHistoryVariables;
    }
  | {
      path: '/game/live-wins';
      operationId: 'gameControllerGetLiveWins';
      variables: GameControllerGetLiveWinsVariables;
    }
  | {
      path: '/game/live-big-wins';
      operationId: 'gameControllerGetBigWins';
      variables: GameControllerGetBigWinsVariables;
    }
  | {
      path: '/game/live-lucky-wins';
      operationId: 'gameControllerGetLiveLuckyWins';
      variables: GameControllerGetLiveLuckyWinsVariables;
    }
  | {
      path: '/game/lucky-wins';
      operationId: 'gameControllerGetLuckyWins';
      variables: GameControllerGetLuckyWinsVariables;
    }
  | {
      path: '/game/top-bets';
      operationId: 'gameControllerGetTopBets';
      variables: GameControllerGetTopBetsVariables;
    }
  | {
      path: '/game/stats-by-player';
      operationId: 'gameControllerGetStatsByPlayer';
      variables: GameControllerGetStatsByPlayerVariables;
    }
  | {
      path: '/game/sse-live-wins';
      operationId: 'gameControllerSseLiveWins';
      variables: GameControllerSseLiveWinsVariables;
    }
  | {
      path: '/statistic/stats';
      operationId: 'statisticControllerGetStats';
      variables: StatisticControllerGetStatsVariables;
    }
  | {
      path: '/statistic/mininig-stats';
      operationId: 'statisticControllerGetMiningStats';
      variables: StatisticControllerGetMiningStatsVariables;
    }
  | {
      path: '/statistic/dashboard-stats';
      operationId: 'statisticControllerGetDashboardStats';
      variables: StatisticControllerGetDashboardStatsVariables;
    }
  | {
      path: '/statistic/volume-leaderboard-list';
      operationId: 'statisticControllerGetLeaderboardListByVolume';
      variables: StatisticControllerGetLeaderboardListByVolumeVariables;
    }
  | {
      path: '/statistic/profit-leaderboard-list';
      operationId: 'statisticControllerGetLeaderboardListByProfit';
      variables: StatisticControllerGetLeaderboardListByProfitVariables;
    }
  | {
      path: '/statistic/lucky-leaderboard-list';
      operationId: 'statisticControllerGetLeaderboardListByLuckyWinner';
      variables: StatisticControllerGetLeaderboardListByLuckyWinnerVariables;
    }
  | {
      path: '/statistic/bigwins-leaderboard-list';
      operationId: 'statisticControllerGetLeaderboardListBigWins';
      variables: StatisticControllerGetLeaderboardListBigWinsVariables;
    }
  | {
      path: '/statistic/loss-legends-leaderboard-list';
      operationId: 'statisticControllerGetLeaderboardListLossLegends';
      variables: StatisticControllerGetLeaderboardListLossLegendsVariables;
    }
  | {
      path: '/bankroll/update-notify-single-sided-pools';
      operationId: 'bankrollControllerUpdateSingleSidedPoolsNotify';
      variables: BankrollControllerUpdateSingleSidedPoolsNotifyVariables;
    }
  | {
      path: '/bankroll/wager-info';
      operationId: 'bankrollControllerGetWagerInfo';
      variables: BankrollControllerGetWagerInfoVariables;
    }
  | {
      path: '/bankroll/single-sided-pools';
      operationId: 'bankrollControllerGetSingleSidedPools';
      variables: BankrollControllerGetSingleSidedPoolsVariables;
    }
  | {
      path: '/bankroll/pool-list';
      operationId: 'bankrollControllerGetPoolList';
      variables: BankrollControllerGetPoolListVariables;
    }
  | {
      path: '/referral/referral-history/{wallet}';
      operationId: 'referralControllerGetReferralHistoryByPlayer';
      variables: ReferralControllerGetReferralHistoryByPlayerVariables;
    }
  | {
      path: '/referral/rewards-distribution-history/{wallet}';
      operationId: 'referralControllerRewardsDistributionHistory';
      variables: ReferralControllerRewardsDistributionHistoryVariables;
    }
  | {
      path: '/referral/code-volume-and-rewards';
      operationId: 'referralControllerCodesVolumeAndRewardAmounts';
      variables: ReferralControllerCodesVolumeAndRewardAmountsVariables;
    }
  | {
      path: '/stake/summary';
      operationId: 'stakeControllerSummary';
      variables: StakeControllerSummaryVariables;
    }
  | {
      path: '/history';
      operationId: 'bridgeControllerHistory';
      variables: BridgeControllerHistoryVariables;
    }
  | {
      path: '/latest';
      operationId: 'bridgeControllerLatest';
      variables: BridgeControllerLatestVariables;
    };
